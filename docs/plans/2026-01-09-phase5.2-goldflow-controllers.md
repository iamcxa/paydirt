# Phase 5.2: Goldflow Controllers

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build specialized controllers that orchestrate Goldflow pipelines: TrailBossController for caravan coordination and ClaimAgentController for Q&A decision handling.

**Architecture:** Controllers are the orchestration layer of Goldflow. They coordinate Sources, Processors, Verifiers, Sinks, handle retry logic, manage parallel execution, and interface with bd CLI for state tracking. Controllers map to Paydirt's Trail Boss and Claim Agent prospects.

**Tech Stack:** Deno/TypeScript, bd CLI for state, tmux for process management

---

## Prerequisites

- Completed Phase 5.1 (BaseController, types, metrics)
- Existing prospects at `paydirt/prospects/trail-boss.md` and `paydirt/prospects/claim-agent.md`
- bd CLI installed

---

## Task 5.2.1: Create TrailBossController

**bd issue:** Create via `bd create --title="Create TrailBossController" --type=task`

**Files:**
- Create: `src/goldflow/controllers/trail-boss.ts`
- Test: `src/goldflow/controllers/trail-boss.test.ts`
- Modify: `src/goldflow/controllers/mod.ts`

### Step 1: Write the failing test

Create `src/goldflow/controllers/trail-boss.test.ts`:

```typescript
// src/goldflow/controllers/trail-boss.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { TrailBossController } from './trail-boss.ts';
import type { GoldflowComponent, Processor, Verifier } from '../types.ts';

// Mock processor
const mockMiner: Processor = {
  type: 'processor',
  name: 'miner',
  config: {},
  superpowers: ['executing-plans', 'test-driven-development'],
  process: async (input) => ({
    success: true,
    data: { code: 'function foo() {}', tests: 'test("foo", ...)' },
    metrics: { startTime: Date.now(), endTime: Date.now() + 1000 },
  }),
};

// Mock verifier
const mockAssayer: Verifier = {
  type: 'verifier',
  name: 'assayer',
  config: {},
  gates: ['tests_pass', 'lint_clean'],
  verify: async (input) => ({
    success: true,
    data: [
      { gateName: 'tests_pass', passed: true, message: 'All tests passed' },
      { gateName: 'lint_clean', passed: true, message: 'No lint errors' },
    ],
    metrics: { startTime: Date.now(), endTime: Date.now() + 500 },
  }),
};

Deno.test('TrailBossController - extends BaseController', () => {
  const controller = new TrailBossController('trail-boss-1');

  assertEquals(controller.name, 'trail-boss-1');
  assertEquals(controller.type, 'controller');
});

Deno.test('TrailBossController - has required superpowers', () => {
  const controller = new TrailBossController('trail-boss-1');

  assertExists(controller.superpowers);
  assertEquals(controller.superpowers?.includes('dispatching-parallel-agents'), true);
  assertEquals(controller.superpowers?.includes('finishing-a-development-branch'), true);
});

Deno.test('TrailBossController - orchestrate() executes components in sequence', async () => {
  const controller = new TrailBossController('trail-boss-1');

  const result = await controller.orchestrate([mockMiner, mockAssayer]);

  assertEquals(result.success, true);
  assertExists(result.metrics);
});

Deno.test('TrailBossController - runPipeline() processes through stages', async () => {
  const controller = new TrailBossController('trail-boss-1');

  const result = await controller.runPipeline({
    input: { task: 'Implement auth' },
    processors: [mockMiner],
    verifiers: [mockAssayer],
  });

  assertEquals(result.success, true);
  if (result.success) {
    assertExists(result.data.processorResults);
    assertExists(result.data.verifierResults);
  }
});

Deno.test('TrailBossController - handles processor failure', async () => {
  const failingProcessor: Processor = {
    ...mockMiner,
    name: 'failing-miner',
    process: async () => ({
      success: false,
      error: 'Context exhausted',
      metrics: { startTime: Date.now(), endTime: Date.now() },
    }),
  };

  const controller = new TrailBossController('trail-boss-1', { retryPolicy: 1 });
  const result = await controller.runPipeline({
    input: { task: 'Test' },
    processors: [failingProcessor],
    verifiers: [],
  });

  assertEquals(result.success, false);
});

Deno.test('TrailBossController - buildProspectArgs() creates argument array', () => {
  const controller = new TrailBossController('trail-boss-1');

  const args = controller.buildProspectArgs({
    role: 'surveyor',
    task: 'Design authentication flow',
    claimId: 'pd-abc123',
    caravanName: 'auth-feature',
    paydirtInstallDir: '/opt/paydirt',
    userProjectDir: '/home/user/project',
  });

  // Should include plugin-dir, add-dir, agent arguments
  assertEquals(args.includes('--plugin-dir'), true);
  assertEquals(args.includes('--agent'), true);
  assertEquals(args.some(a => a.includes('prospects/surveyor.md')), true);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/controllers/trail-boss.test.ts
```

Expected: FAIL with module not found

### Step 3: Create trail-boss.ts

Create `src/goldflow/controllers/trail-boss.ts`:

```typescript
// src/goldflow/controllers/trail-boss.ts
import { BaseController, type ControllerConfig } from './base.ts';
import type {
  GoldflowComponent,
  GoldflowResult,
  Processor,
  Verifier,
  GateResult,
} from '../types.ts';
import type { ProspectRole } from '../../types.ts';

export interface PipelineInput {
  input: unknown;
  processors: Processor[];
  verifiers: Verifier[];
}

export interface PipelineOutput {
  processorResults: Array<{ name: string; result: GoldflowResult<unknown> }>;
  verifierResults: Array<{ name: string; result: GoldflowResult<GateResult[]> }>;
}

export interface SpawnOptions {
  role: ProspectRole;
  task: string;
  claimId: string;
  caravanName: string;
  paydirtInstallDir: string;
  userProjectDir: string;
  tunnelPath?: string;
  background?: boolean;
}

/**
 * TrailBossController - Caravan coordination controller.
 *
 * The Trail Boss orchestrates the caravan's journey from task intake
 * to delivery. It delegates to specialists (Surveyor, Miner, etc.)
 * and coordinates the verification pipeline.
 *
 * Goldflow mapping: Controller
 * Paydirt mapping: Trail Boss prospect
 */
export class TrailBossController extends BaseController {
  constructor(name: string, config: ControllerConfig = {}) {
    super(name, {
      ...config,
      superpowers: [
        'dispatching-parallel-agents',
        'finishing-a-development-branch',
        ...(config.superpowers || []),
      ],
    });
  }

  /**
   * Orchestrate a set of components sequentially.
   */
  async orchestrate(components: GoldflowComponent[]): Promise<GoldflowResult<void>> {
    const startTime = Date.now();

    for (const component of components) {
      if (component.type === 'processor') {
        const processor = component as Processor;
        const result = await processor.process({});
        if (!result.success) {
          return {
            success: false,
            error: `Processor ${processor.name} failed: ${result.error}`,
            metrics: { startTime, endTime: Date.now() },
          };
        }
      } else if (component.type === 'verifier') {
        const verifier = component as Verifier;
        const result = await verifier.verify({});
        if (!result.success) {
          return {
            success: false,
            error: `Verifier ${verifier.name} failed: ${result.error}`,
            metrics: { startTime, endTime: Date.now() },
          };
        }
      }
    }

    return {
      success: true,
      data: undefined,
      metrics: { startTime, endTime: Date.now() },
    };
  }

  /**
   * Run a complete pipeline with processors and verifiers.
   */
  async runPipeline(pipeline: PipelineInput): Promise<GoldflowResult<PipelineOutput>> {
    const startTime = Date.now();
    const output: PipelineOutput = {
      processorResults: [],
      verifierResults: [],
    };

    // Run processors
    for (const processor of pipeline.processors) {
      const result = await this.withRetry(
        () => processor.process(pipeline.input),
        this.config.retryPolicy,
      );

      output.processorResults.push({ name: processor.name, result });

      if (!result.success) {
        return {
          success: false,
          error: `Processor ${processor.name} failed: ${result.error}`,
          metrics: { startTime, endTime: Date.now() },
        };
      }
    }

    // Run verifiers
    for (const verifier of pipeline.verifiers) {
      const result = await verifier.verify(output.processorResults);
      output.verifierResults.push({ name: verifier.name, result });

      // Note: Verifier returning success:true doesn't mean all gates passed
      // The caller should check the gate results
    }

    return {
      success: true,
      data: output,
      metrics: { startTime, endTime: Date.now() },
    };
  }

  /**
   * Build environment variables for a prospect spawn.
   */
  buildProspectEnvVars(options: SpawnOptions): Record<string, string> {
    const vars: Record<string, string> = {
      PAYDIRT_PROSPECT: options.role,
      PAYDIRT_CLAIM: options.claimId,
      PAYDIRT_CARAVAN: options.caravanName,
      PAYDIRT_SESSION: `paydirt-${options.claimId}`,
      PAYDIRT_BIN: `${options.paydirtInstallDir}/paydirt`,
    };

    if (options.tunnelPath) {
      vars.PAYDIRT_TUNNEL = options.tunnelPath;
    }

    return vars;
  }

  /**
   * Build argument array for spawning a prospect via Claude Code CLI.
   *
   * Uses:
   * - --plugin-dir to load paydirt as plugin (agents, commands, skills)
   * - --add-dir to grant access to directories
   * - --agent to specify the prospect's agent file
   *
   * Returns an array of arguments (safe for use with execFile/spawn).
   */
  buildProspectArgs(options: SpawnOptions): string[] {
    const {
      role,
      task,
      paydirtInstallDir,
      userProjectDir,
    } = options;

    const args: string[] = [
      '--plugin-dir', paydirtInstallDir,
      '--add-dir', paydirtInstallDir,
      '--add-dir', userProjectDir,
      '--agent', `${paydirtInstallDir}/prospects/${role}.md`,
      task,
    ];

    return args;
  }

  /**
   * Format status for bd comment.
   */
  toBdComment(status: string, details?: Record<string, unknown>): string {
    const base = `PROGRESS: ${status}`;
    if (details) {
      const detailStr = Object.entries(details)
        .map(([k, v]) => `${k}=${v}`)
        .join(', ');
      return `${base}\n${detailStr}`;
    }
    return base;
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/controllers/trail-boss.test.ts
```

Expected: PASS (all 6 tests)

### Step 5: Update mod.ts

Modify `src/goldflow/controllers/mod.ts`:

```typescript
// src/goldflow/controllers/mod.ts
export { BaseController, type ControllerConfig } from './base.ts';
export {
  TrailBossController,
  type PipelineInput,
  type PipelineOutput,
  type SpawnOptions,
} from './trail-boss.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/controllers/
git commit -m "feat(goldflow): add TrailBossController with pipeline execution"
```

---

## Task 5.2.2: Create ClaimAgentController

**bd issue:** Create via `bd create --title="Create ClaimAgentController" --type=task`

**Files:**
- Create: `src/goldflow/controllers/claim-agent.ts`
- Test: `src/goldflow/controllers/claim-agent.test.ts`
- Modify: `src/goldflow/controllers/mod.ts`

### Step 1: Write the failing test

Create `src/goldflow/controllers/claim-agent.test.ts`:

```typescript
// src/goldflow/controllers/claim-agent.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { ClaimAgentController, type Question, type Answer } from './claim-agent.ts';

Deno.test('ClaimAgentController - extends BaseController', () => {
  const controller = new ClaimAgentController('claim-agent-1');

  assertEquals(controller.name, 'claim-agent-1');
  assertEquals(controller.type, 'controller');
});

Deno.test('ClaimAgentController - parseQuestion() extracts question type', () => {
  const controller = new ClaimAgentController('claim-agent-1');

  const q1 = controller.parseQuestion('QUESTION [decision]: Which auth provider?');
  assertEquals(q1?.type, 'decision');
  assertEquals(q1?.content, 'Which auth provider?');

  const q2 = controller.parseQuestion('QUESTION [clarification]: What scope?');
  assertEquals(q2?.type, 'clarification');

  const q3 = controller.parseQuestion('QUESTION [approval]: Proceed with deploy?');
  assertEquals(q3?.type, 'approval');
});

Deno.test('ClaimAgentController - parseQuestion() extracts options', () => {
  const controller = new ClaimAgentController('claim-agent-1');

  const comment = `QUESTION [decision]: Which auth provider?
OPTIONS:
- Supabase Auth
- Firebase Auth
- Custom JWT`;

  const q = controller.parseQuestion(comment);

  assertExists(q?.options);
  assertEquals(q?.options?.length, 3);
  assertEquals(q?.options?.[0], 'Supabase Auth');
});

Deno.test('ClaimAgentController - answerFromContext() finds matching answer', async () => {
  const controller = new ClaimAgentController('claim-agent-1');

  // Load context with pre-defined answers
  controller.loadContext(`
## Pre-Defined Answers

### Authentication
Q: Which auth provider should we use?
A: Use Supabase Auth. It integrates with our existing Supabase setup.

### Database
Q: Which database?
A: PostgreSQL via Supabase.
`);

  const question: Question = {
    type: 'decision',
    content: 'Which auth provider should we use?',
    options: ['Supabase Auth', 'Firebase Auth'],
  };

  const answer = await controller.answerFromContext(question);

  assertEquals(answer.confidence, 'high');
  assertEquals(answer.content.includes('Supabase'), true);
});

Deno.test('ClaimAgentController - answerFromContext() returns low confidence when no match', async () => {
  const controller = new ClaimAgentController('claim-agent-1');

  controller.loadContext('No relevant answers here.');

  const question: Question = {
    type: 'decision',
    content: 'What color should the button be?',
  };

  const answer = await controller.answerFromContext(question);

  assertEquals(answer.confidence === 'low' || answer.confidence === 'none', true);
});

Deno.test('ClaimAgentController - formatAnswer() creates bd comment format', () => {
  const controller = new ClaimAgentController('claim-agent-1');

  const answer: Answer = {
    content: 'Use Supabase Auth',
    confidence: 'high',
    reasoning: 'Context file specifies Supabase ecosystem',
  };

  const formatted = controller.formatAnswer(answer);

  assertEquals(formatted.includes('ANSWER [high]:'), true);
  assertEquals(formatted.includes('Use Supabase Auth'), true);
  assertEquals(formatted.includes('Reasoning:'), true);
});

Deno.test('ClaimAgentController - shouldEscalate() returns true for low/none confidence', () => {
  const controller = new ClaimAgentController('claim-agent-1');

  assertEquals(controller.shouldEscalate({ content: '', confidence: 'high' }), false);
  assertEquals(controller.shouldEscalate({ content: '', confidence: 'medium' }), false);
  assertEquals(controller.shouldEscalate({ content: '', confidence: 'low' }), true);
  assertEquals(controller.shouldEscalate({ content: '', confidence: 'none' }), true);
  assertEquals(controller.shouldEscalate({ content: '', confidence: 'escalated' }), true);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/controllers/claim-agent.test.ts
```

Expected: FAIL with module not found

### Step 3: Create claim-agent.ts

Create `src/goldflow/controllers/claim-agent.ts`:

```typescript
// src/goldflow/controllers/claim-agent.ts
import { BaseController, type ControllerConfig } from './base.ts';
import type { GoldflowResult, ConfidenceLevel } from '../types.ts';

export type QuestionType = 'decision' | 'clarification' | 'approval';

export interface Question {
  type: QuestionType;
  content: string;
  options?: string[];
  from?: string;
  timestamp?: number;
}

export interface Answer {
  content: string;
  confidence: ConfidenceLevel;
  reasoning?: string;
  source?: 'context' | 'inference' | 'human';
}

export interface Decision {
  id: string;
  question: Question;
  answer: Answer;
  timestamp: number;
  caravanId?: string;
}

/**
 * ClaimAgentController - Q&A decision handling controller.
 *
 * The Claim Agent represents the Chief Prospector (human) in making
 * decisions. It reads pre-defined answers from context files and
 * escalates to human when confidence is low.
 *
 * Goldflow mapping: Controller
 * Paydirt mapping: Claim Agent prospect
 */
export class ClaimAgentController extends BaseController {
  private context: string = '';
  private decisions: Decision[] = [];

  constructor(name: string, config: ControllerConfig = {}) {
    super(name, config);
  }

  /**
   * Load context from a tunnel/context file.
   */
  loadContext(content: string): void {
    this.context = content;
  }

  /**
   * Parse a QUESTION comment from bd.
   */
  parseQuestion(comment: string): Question | null {
    // Match: QUESTION [type]: content
    const match = comment.match(/^QUESTION\s*\[(\w+)\]:\s*(.+?)(?:\nOPTIONS:|$)/s);
    if (!match) return null;

    const type = match[1] as QuestionType;
    const content = match[2].trim();

    // Extract options if present
    const optionsMatch = comment.match(/OPTIONS:\n((?:- .+\n?)+)/);
    let options: string[] | undefined;

    if (optionsMatch) {
      options = optionsMatch[1]
        .split('\n')
        .map((line) => line.replace(/^-\s*/, '').trim())
        .filter((line) => line.length > 0);
    }

    return { type, content, options };
  }

  /**
   * Try to answer a question from loaded context.
   */
  async answerFromContext(question: Question): Promise<Answer> {
    const content = question.content.toLowerCase();

    // Simple keyword matching for now
    // In production, this would use semantic search or LLM

    // Look for Q&A patterns in context
    const qaPattern = /Q:\s*(.+?)\nA:\s*(.+?)(?=\n\n|\n#|$)/gs;
    let match;

    while ((match = qaPattern.exec(this.context)) !== null) {
      const contextQuestion = match[1].toLowerCase();
      const contextAnswer = match[2].trim();

      // Check for keyword overlap
      const questionWords = content.split(/\s+/);
      const contextWords = contextQuestion.split(/\s+/);
      const overlap = questionWords.filter((w) =>
        contextWords.some((cw) => cw.includes(w) || w.includes(cw))
      );

      if (overlap.length >= 2) {
        return {
          content: contextAnswer,
          confidence: 'high',
          reasoning: `Found matching Q&A in context file`,
          source: 'context',
        };
      }
    }

    // Check for section headers matching keywords
    const keywords = content.match(/\b\w{4,}\b/g) || [];
    for (const keyword of keywords) {
      const sectionPattern = new RegExp(`###?\\s*${keyword}[\\s\\S]*?(?=###|$)`, 'i');
      const sectionMatch = this.context.match(sectionPattern);

      if (sectionMatch) {
        // Found a relevant section, but no exact Q&A
        return {
          content: `Based on context section about "${keyword}", but no direct answer found.`,
          confidence: 'medium',
          reasoning: `Found relevant section but no exact match`,
          source: 'inference',
        };
      }
    }

    // No match found
    return {
      content: 'Unable to find answer in context',
      confidence: 'none',
      reasoning: 'No matching Q&A or relevant section found',
      source: 'context',
    };
  }

  /**
   * Format an answer for bd comment.
   */
  formatAnswer(answer: Answer): string {
    let result = `ANSWER [${answer.confidence}]: ${answer.content}`;

    if (answer.reasoning) {
      result += `\nReasoning: ${answer.reasoning}`;
    }

    if (answer.source) {
      result += `\nSource: ${answer.source}`;
    }

    return result;
  }

  /**
   * Check if an answer should be escalated to human.
   */
  shouldEscalate(answer: Answer): boolean {
    return ['low', 'none', 'escalated'].includes(answer.confidence);
  }

  /**
   * Record a decision for the ledger.
   */
  recordDecision(question: Question, answer: Answer, caravanId?: string): Decision {
    const decision: Decision = {
      id: `dec-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      question,
      answer,
      timestamp: Date.now(),
      caravanId,
    };

    this.decisions.push(decision);
    return decision;
  }

  /**
   * Get all recorded decisions.
   */
  getDecisions(): Decision[] {
    return [...this.decisions];
  }

  /**
   * Format decision for bd ledger comment.
   */
  formatDecisionForLedger(decision: Decision): string {
    return `DECISION caravan=${decision.caravanId || 'unknown'}
Q: ${decision.question.content}
A: ${decision.answer.content}
Confidence: ${decision.answer.confidence}
Source: ${decision.answer.source || 'unknown'}
Reasoning: ${decision.answer.reasoning || 'N/A'}
Timestamp: ${new Date(decision.timestamp).toISOString()}`;
  }

  /**
   * Format escalation for bd comment.
   */
  formatEscalation(question: Question): string {
    let result = `ESCALATE: Need human decision\n`;
    result += `Question [${question.type}]: ${question.content}`;

    if (question.options) {
      result += `\nOptions:\n${question.options.map((o) => `- ${o}`).join('\n')}`;
    }

    return result;
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/controllers/claim-agent.test.ts
```

Expected: PASS (all 7 tests)

### Step 5: Update mod.ts

Modify `src/goldflow/controllers/mod.ts`:

```typescript
// src/goldflow/controllers/mod.ts
export { BaseController, type ControllerConfig } from './base.ts';
export {
  TrailBossController,
  type PipelineInput,
  type PipelineOutput,
  type SpawnOptions,
} from './trail-boss.ts';
export {
  ClaimAgentController,
  type Question,
  type Answer,
  type Decision,
  type QuestionType,
} from './claim-agent.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/controllers/
git commit -m "feat(goldflow): add ClaimAgentController with Q&A handling"
```

---

## Task 5.2.3: Create CampBossController

**bd issue:** Create via `bd create --title="Create CampBossController" --type=task`

**Files:**
- Create: `src/goldflow/controllers/camp-boss.ts`
- Test: `src/goldflow/controllers/camp-boss.test.ts`
- Modify: `src/goldflow/controllers/mod.ts`

### Step 1: Write the failing test

Create `src/goldflow/controllers/camp-boss.test.ts`:

```typescript
// src/goldflow/controllers/camp-boss.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { CampBossController, type IntakeDecision, type JournalEntry } from './camp-boss.ts';

Deno.test('CampBossController - extends BaseController', () => {
  const controller = new CampBossController('camp-boss');

  assertEquals(controller.name, 'camp-boss');
  assertEquals(controller.type, 'controller');
});

Deno.test('CampBossController - makeIntakeDecision() returns STAKE for high priority', () => {
  const controller = new CampBossController('camp-boss');

  const decision = controller.makeIntakeDecision({
    title: 'Fix critical bug',
    source: 'linear',
    priority: 0, // P0
    externalId: 'LIN-123',
  });

  assertEquals(decision.action, 'stake');
  assertEquals(decision.priority, 0);
});

Deno.test('CampBossController - makeIntakeDecision() returns BACKLOG for low priority', () => {
  const controller = new CampBossController('camp-boss');

  const decision = controller.makeIntakeDecision({
    title: 'Nice to have feature',
    source: 'user',
    priority: 3, // P3
  });

  assertEquals(decision.action, 'backlog');
});

Deno.test('CampBossController - logJournalEntry() adds entry', () => {
  const controller = new CampBossController('camp-boss');

  controller.logJournalEntry({
    type: 'observation',
    content: 'Caravan auth-feature completed planning',
    caravanId: 'pd-abc123',
  });

  const entries = controller.getJournalEntries();
  assertEquals(entries.length, 1);
  assertEquals(entries[0].type, 'observation');
});

Deno.test('CampBossController - formatJournalEntry() creates bd comment format', () => {
  const controller = new CampBossController('camp-boss');

  const entry: JournalEntry = {
    type: 'intake_decision',
    content: 'LIN-123 to STAKE',
    timestamp: Date.now(),
  };

  const formatted = controller.formatJournalEntry(entry);

  assertEquals(formatted.includes('INTAKE_DECISION:'), true);
  assertEquals(formatted.includes('LIN-123 to STAKE'), true);
});

Deno.test('CampBossController - getJournalByType() filters correctly', () => {
  const controller = new CampBossController('camp-boss');

  controller.logJournalEntry({ type: 'observation', content: 'obs1' });
  controller.logJournalEntry({ type: 'discovery', content: 'disc1' });
  controller.logJournalEntry({ type: 'observation', content: 'obs2' });

  const observations = controller.getJournalByType('observation');
  assertEquals(observations.length, 2);

  const discoveries = controller.getJournalByType('discovery');
  assertEquals(discoveries.length, 1);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/controllers/camp-boss.test.ts
```

Expected: FAIL with module not found

### Step 3: Create camp-boss.ts

Create `src/goldflow/controllers/camp-boss.ts`:

```typescript
// src/goldflow/controllers/camp-boss.ts
import { BaseController, type ControllerConfig } from './base.ts';

export type JournalEntryType =
  | 'discovery'
  | 'request'
  | 'intake_decision'
  | 'observation'
  | 'goal_update'
  | 'linear_sync';

export type IntakeAction = 'stake' | 'backlog' | 'reject';

export interface TaskIntake {
  title: string;
  source: 'linear' | 'github' | 'user' | 'scout';
  priority: number; // 0-4 (0=P0 urgent, 4=backlog)
  externalId?: string;
  url?: string;
  metadata?: Record<string, unknown>;
}

export interface IntakeDecision {
  action: IntakeAction;
  priority: number;
  reason: string;
  caravanId?: string;
  timestamp: number;
}

export interface JournalEntry {
  type: JournalEntryType;
  content: string;
  timestamp?: number;
  caravanId?: string;
  metadata?: Record<string, unknown>;
}

/**
 * CampBossController - Strategic oversight controller.
 *
 * The Camp Boss manages the overall operation, handling task intake
 * from scouts and users, maintaining the commander journal, and
 * coordinating multiple caravans.
 *
 * Goldflow mapping: Controller
 * Paydirt mapping: Camp Boss prospect
 */
export class CampBossController extends BaseController {
  private journal: JournalEntry[] = [];

  constructor(name: string, config: ControllerConfig = {}) {
    super(name, {
      ...config,
      superpowers: ['dispatching-parallel-agents', ...(config.superpowers || [])],
    });
  }

  /**
   * Make an intake decision for a new task.
   */
  makeIntakeDecision(task: TaskIntake): IntakeDecision {
    let action: IntakeAction;
    let reason: string;

    // Priority-based routing
    if (task.priority <= 1) {
      // P0 or P1 - stake immediately
      action = 'stake';
      reason = `High priority (P${task.priority}) - starting new caravan`;
    } else if (task.priority === 2) {
      // P2 - stake if capacity available
      action = 'stake';
      reason = `Medium priority (P${task.priority}) - queueing for caravan`;
    } else {
      // P3+ - backlog
      action = 'backlog';
      reason = `Low priority (P${task.priority}) - adding to backlog`;
    }

    const decision: IntakeDecision = {
      action,
      priority: task.priority,
      reason,
      timestamp: Date.now(),
    };

    // Log to journal
    this.logJournalEntry({
      type: 'intake_decision',
      content: `${task.externalId || task.title} to ${action.toUpperCase()}`,
      metadata: { task, decision },
    });

    return decision;
  }

  /**
   * Log an entry to the commander journal.
   */
  logJournalEntry(entry: Omit<JournalEntry, 'timestamp'> & { timestamp?: number }): void {
    this.journal.push({
      ...entry,
      timestamp: entry.timestamp || Date.now(),
    });
  }

  /**
   * Get all journal entries.
   */
  getJournalEntries(): JournalEntry[] {
    return [...this.journal];
  }

  /**
   * Get journal entries by type.
   */
  getJournalByType(type: JournalEntryType): JournalEntry[] {
    return this.journal.filter((e) => e.type === type);
  }

  /**
   * Get journal entries for a specific caravan.
   */
  getJournalByCaravan(caravanId: string): JournalEntry[] {
    return this.journal.filter((e) => e.caravanId === caravanId);
  }

  /**
   * Format a journal entry for bd comment.
   */
  formatJournalEntry(entry: JournalEntry): string {
    const prefix = entry.type.toUpperCase().replace('_', '_');
    const timestamp = new Date(entry.timestamp || Date.now()).toISOString();

    return `[${timestamp}] ${prefix}: ${entry.content}`;
  }

  /**
   * Format discovery from scout for bd comment.
   */
  formatDiscovery(source: string, title: string, priority: number, externalId?: string): string {
    return `DISCOVERY: [${source}] ${externalId || 'N/A'} assigned
title: ${title}
priority: P${priority}
url: ${externalId ? `https://linear.app/.../${externalId}` : 'N/A'}`;
  }

  /**
   * Format Linear sync status for bd comment.
   */
  formatLinearSync(p0: number, p1: number, p2plus: number): string {
    const timestamp = new Date().toISOString();
    return `LINEAR_SYNC: P0=${p0} P1=${p1} P2+=${p2plus} (${timestamp})`;
  }

  /**
   * Export journal to markdown.
   */
  toMarkdown(): string {
    const lines = ['# Commander Journal', ''];

    for (const entry of this.journal) {
      lines.push(this.formatJournalEntry(entry));
      lines.push('');
    }

    return lines.join('\n');
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/controllers/camp-boss.test.ts
```

Expected: PASS (all 6 tests)

### Step 5: Update mod.ts

Modify `src/goldflow/controllers/mod.ts`:

```typescript
// src/goldflow/controllers/mod.ts
export { BaseController, type ControllerConfig } from './base.ts';
export {
  TrailBossController,
  type PipelineInput,
  type PipelineOutput,
  type SpawnOptions,
} from './trail-boss.ts';
export {
  ClaimAgentController,
  type Question,
  type Answer,
  type Decision,
  type QuestionType,
} from './claim-agent.ts';
export {
  CampBossController,
  type JournalEntry,
  type JournalEntryType,
  type IntakeDecision,
  type IntakeAction,
  type TaskIntake,
} from './camp-boss.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/controllers/
git commit -m "feat(goldflow): add CampBossController with journal and intake"
```

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 5.2.1 | TrailBossController | `controllers/trail-boss.ts`, tests |
| 5.2.2 | ClaimAgentController | `controllers/claim-agent.ts`, tests |
| 5.2.3 | CampBossController | `controllers/camp-boss.ts`, tests |

---

## Final Directory Structure After Phase 5.2

```
src/goldflow/controllers/
├── mod.ts
├── base.ts                # BaseController (from 5.1)
├── base.test.ts
├── trail-boss.ts          # TrailBossController - caravan coordination
├── trail-boss.test.ts
├── claim-agent.ts         # ClaimAgentController - Q&A handling
├── claim-agent.test.ts
├── camp-boss.ts           # CampBossController - strategic oversight
└── camp-boss.test.ts
```

---

## Key Design Patterns

### Claude Code Integration

The `TrailBossController.buildProspectArgs()` returns an array of arguments safe for use with `Deno.Command` or `execFile`:

```typescript
// Safe pattern - returns array for execFile/spawn
const args = controller.buildProspectArgs({
  role: 'surveyor',
  task: 'Design auth flow',
  claimId: 'pd-abc123',
  caravanName: 'auth-feature',
  paydirtInstallDir: '/opt/paydirt',
  userProjectDir: '/home/user/project',
});

// Use with Deno.Command (safe - no shell injection)
const command = new Deno.Command('claude', {
  args,
  env: controller.buildProspectEnvVars(options),
  cwd: userProjectDir,
});
```

This uses:
- `--plugin-dir` to load paydirt as a Claude Code plugin (agents, commands, skills)
- `--add-dir` to grant file access to directories
- `--agent` to specify the prospect's agent file
- Environment variables for caravan context

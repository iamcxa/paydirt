# Phase 5.1: Goldflow Core Infrastructure

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Establish the Goldflow core type system, base classes, and metrics infrastructure that all other Goldflow components depend on.

**Architecture:** Goldflow is the execution layer (Engine) that handles HOW work gets done reliably. It has no narrative/role concepts - those belong to Paydirt (Town). This phase creates the foundational types, result patterns, and metrics collector.

**Tech Stack:** Deno/TypeScript, YAML configuration, bd CLI for state

---

## Prerequisites

- Working paydirt directory at `gastown_b/paydirt/`
- Existing `src/goldflow/types.ts` with basic type definitions
- bd CLI installed and configured

---

## Task 5.1.1: Extend Goldflow Core Types

**bd issue:** Create via `bd create --title="Extend Goldflow core types" --type=task`

**Files:**
- Modify: `src/goldflow/types.ts`
- Test: `src/goldflow/types.test.ts`

### Step 1: Write the failing test

Create `src/goldflow/types.test.ts`:

```typescript
// src/goldflow/types.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import type {
  GoldflowResult,
  MetricEntry,
  ConfidenceLevel,
  GateResult,
} from './types.ts';

Deno.test('GoldflowResult - success result has correct shape', () => {
  const result: GoldflowResult<string> = {
    success: true,
    data: 'test output',
    metrics: {
      startTime: Date.now(),
      endTime: Date.now() + 1000,
      tokensUsed: 100,
    },
  };

  assertEquals(result.success, true);
  assertExists(result.data);
  assertExists(result.metrics);
});

Deno.test('GoldflowResult - failure result has error', () => {
  const result: GoldflowResult<string> = {
    success: false,
    error: 'Something went wrong',
    metrics: {
      startTime: Date.now(),
      endTime: Date.now() + 500,
      tokensUsed: 50,
    },
  };

  assertEquals(result.success, false);
  assertExists(result.error);
});

Deno.test('MetricEntry - has required fields', () => {
  const entry: MetricEntry = {
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1500,
    tokensUsed: 200,
    success: true,
  };

  assertExists(entry.timestamp);
  assertExists(entry.component);
  assertEquals(entry.componentType, 'processor');
});

Deno.test('GateResult - captures verification outcome', () => {
  const gate: GateResult = {
    gateName: 'tests_pass',
    passed: true,
    message: 'All 42 tests passed',
    details: { testCount: 42, failCount: 0 },
  };

  assertEquals(gate.passed, true);
  assertExists(gate.message);
});

Deno.test('ConfidenceLevel - all levels are valid', () => {
  const levels: ConfidenceLevel[] = ['high', 'medium', 'low', 'none', 'escalated'];
  assertEquals(levels.length, 5);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/types.test.ts
```

Expected: FAIL with type import errors (types don't exist yet)

### Step 3: Extend types.ts with new types

Modify `src/goldflow/types.ts`:

```typescript
// src/goldflow/types.ts
/**
 * Goldflow - Execution Engine Types
 *
 * Goldflow is the execution layer that handles HOW work gets done reliably.
 * It has no narrative/role concepts - those belong to Paydirt layer.
 */

// ============================================
// Core Enums and Basic Types
// ============================================

export type ComponentType = 'source' | 'stage' | 'processor' | 'verifier' | 'sink' | 'controller';

export type ConfidenceLevel = 'high' | 'medium' | 'low' | 'none' | 'escalated';

// ============================================
// Result Types (for consistent error handling)
// ============================================

export interface ResultMetrics {
  startTime: number;
  endTime: number;
  tokensUsed?: number;
}

export type GoldflowResult<T> =
  | { success: true; data: T; metrics: ResultMetrics }
  | { success: false; error: string; metrics: ResultMetrics };

// ============================================
// Metrics Types
// ============================================

export interface MetricEntry {
  timestamp: number;
  component: string;
  componentType: ComponentType;
  duration: number;
  tokensUsed?: number;
  success: boolean;
  error?: string;
  metadata?: Record<string, unknown>;
}

// ============================================
// Gate/Verification Types
// ============================================

export interface GateResult {
  gateName: string;
  passed: boolean;
  message: string;
  details?: Record<string, unknown>;
}

// ============================================
// Component Interfaces
// ============================================

export interface GoldflowComponent {
  type: ComponentType;
  name: string;
  config: Record<string, unknown>;
}

export interface Source extends GoldflowComponent {
  type: 'source';
  fetch: () => Promise<GoldflowResult<unknown>>;
}

export interface Stage extends GoldflowComponent {
  type: 'stage';
  process: (input: unknown) => Promise<GoldflowResult<unknown>>;
}

export interface Processor extends GoldflowComponent {
  type: 'processor';
  superpowers: string[];
  retryPolicy?: number;
  timeout?: number;
  process: (input: unknown) => Promise<GoldflowResult<unknown>>;
}

export interface Verifier extends GoldflowComponent {
  type: 'verifier';
  superpowers?: string[];
  gates: string[];
  verify: (input: unknown) => Promise<GoldflowResult<GateResult[]>>;
}

export interface Sink extends GoldflowComponent {
  type: 'sink';
  output: (data: unknown) => Promise<GoldflowResult<void>>;
}

export interface Controller extends GoldflowComponent {
  type: 'controller';
  superpowers?: string[];
  maxParallel?: number;
  orchestrate: (components: GoldflowComponent[]) => Promise<GoldflowResult<void>>;
}

// ============================================
// Pipeline Types
// ============================================

export interface Pipeline {
  name: string;
  trigger: string;
  stages: PipelineStage[];
}

export interface PipelineStage {
  name: string;
  processor?: string;
  verifier?: string;
  superpowers?: string[];
  onFail?: 'return_to_miner' | 'abort' | 'continue';
  requires?: Record<string, string>;
}

export interface GoldflowConfig {
  processors: Record<string, Partial<Processor>>;
  verifiers: Record<string, Partial<Verifier>>;
  controllers: Record<string, Partial<Controller>>;
  pipelines: Record<string, Pipeline>;
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/types.test.ts
```

Expected: PASS (all 5 tests)

### Step 5: Commit

```bash
git add src/goldflow/types.ts src/goldflow/types.test.ts
git commit -m "feat(goldflow): extend core types with Result pattern and metrics"
```

---

## Task 5.1.2: Create MetricsCollector

**bd issue:** Create via `bd create --title="Create MetricsCollector" --type=task`

**Files:**
- Create: `src/goldflow/metrics/collector.ts`
- Create: `src/goldflow/metrics/mod.ts`
- Test: `src/goldflow/metrics/collector.test.ts`

### Step 1: Write the failing test

Create `src/goldflow/metrics/collector.test.ts`:

```typescript
// src/goldflow/metrics/collector.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { MetricsCollector } from './collector.ts';

Deno.test('MetricsCollector - record() adds entry', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1500,
    tokensUsed: 200,
    success: true,
  });

  const metrics = collector.getMetrics();
  assertEquals(metrics.length, 1);
  assertEquals(metrics[0].component, 'miner');
});

Deno.test('MetricsCollector - getMetrics() returns all entries', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1000,
    success: true,
  });

  collector.record({
    timestamp: Date.now(),
    component: 'assayer',
    componentType: 'verifier',
    duration: 500,
    success: true,
  });

  const metrics = collector.getMetrics();
  assertEquals(metrics.length, 2);
});

Deno.test('MetricsCollector - getByComponent() filters correctly', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1000,
    success: true,
  });

  collector.record({
    timestamp: Date.now(),
    component: 'assayer',
    componentType: 'verifier',
    duration: 500,
    success: true,
  });

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 800,
    success: false,
  });

  const minerMetrics = collector.getByComponent('miner');
  assertEquals(minerMetrics.length, 2);
});

Deno.test('MetricsCollector - aggregate() calculates stats', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1000,
    tokensUsed: 100,
    success: true,
  });

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 2000,
    tokensUsed: 200,
    success: true,
  });

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 500,
    tokensUsed: 50,
    success: false,
  });

  const stats = collector.aggregate();

  assertEquals(stats.totalEntries, 3);
  assertEquals(stats.successCount, 2);
  assertEquals(stats.failureCount, 1);
  assertEquals(stats.totalDuration, 3500);
  assertEquals(stats.totalTokens, 350);
  assertEquals(stats.averageDuration, 3500 / 3);
});

Deno.test('MetricsCollector - clear() removes all entries', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: Date.now(),
    component: 'miner',
    componentType: 'processor',
    duration: 1000,
    success: true,
  });

  collector.clear();

  assertEquals(collector.getMetrics().length, 0);
});

Deno.test('MetricsCollector - toJSON() exports correctly', () => {
  const collector = new MetricsCollector();

  collector.record({
    timestamp: 1704067200000,
    component: 'miner',
    componentType: 'processor',
    duration: 1000,
    success: true,
  });

  const json = collector.toJSON();
  const parsed = JSON.parse(json);

  assertExists(parsed.entries);
  assertExists(parsed.aggregate);
  assertEquals(parsed.entries.length, 1);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/metrics/collector.test.ts
```

Expected: FAIL with module not found error

### Step 3: Create collector.ts

Create `src/goldflow/metrics/collector.ts`:

```typescript
// src/goldflow/metrics/collector.ts
import type { MetricEntry, ComponentType } from '../types.ts';

export interface AggregateStats {
  totalEntries: number;
  successCount: number;
  failureCount: number;
  totalDuration: number;
  totalTokens: number;
  averageDuration: number;
  byComponent: Record<string, { count: number; successRate: number; avgDuration: number }>;
}

export class MetricsCollector {
  private entries: MetricEntry[] = [];

  /**
   * Record a new metric entry.
   */
  record(entry: MetricEntry): void {
    this.entries.push(entry);
  }

  /**
   * Get all recorded metrics.
   */
  getMetrics(): MetricEntry[] {
    return [...this.entries];
  }

  /**
   * Filter metrics by component name.
   */
  getByComponent(component: string): MetricEntry[] {
    return this.entries.filter((e) => e.component === component);
  }

  /**
   * Filter metrics by component type.
   */
  getByType(componentType: ComponentType): MetricEntry[] {
    return this.entries.filter((e) => e.componentType === componentType);
  }

  /**
   * Calculate aggregate statistics.
   */
  aggregate(): AggregateStats {
    const totalEntries = this.entries.length;
    const successCount = this.entries.filter((e) => e.success).length;
    const failureCount = totalEntries - successCount;
    const totalDuration = this.entries.reduce((sum, e) => sum + e.duration, 0);
    const totalTokens = this.entries.reduce((sum, e) => sum + (e.tokensUsed || 0), 0);
    const averageDuration = totalEntries > 0 ? totalDuration / totalEntries : 0;

    // Calculate per-component stats
    const byComponent: AggregateStats['byComponent'] = {};
    const componentGroups = new Map<string, MetricEntry[]>();

    for (const entry of this.entries) {
      const group = componentGroups.get(entry.component) || [];
      group.push(entry);
      componentGroups.set(entry.component, group);
    }

    for (const [component, group] of componentGroups) {
      const count = group.length;
      const successes = group.filter((e) => e.success).length;
      const totalDur = group.reduce((sum, e) => sum + e.duration, 0);

      byComponent[component] = {
        count,
        successRate: count > 0 ? successes / count : 0,
        avgDuration: count > 0 ? totalDur / count : 0,
      };
    }

    return {
      totalEntries,
      successCount,
      failureCount,
      totalDuration,
      totalTokens,
      averageDuration,
      byComponent,
    };
  }

  /**
   * Clear all recorded metrics.
   */
  clear(): void {
    this.entries = [];
  }

  /**
   * Export metrics as JSON string.
   */
  toJSON(): string {
    return JSON.stringify({
      entries: this.entries,
      aggregate: this.aggregate(),
    });
  }

  /**
   * Export metrics for bd comment format.
   */
  toBdComment(): string {
    const stats = this.aggregate();
    return `METRICS: entries=${stats.totalEntries}, success=${stats.successCount}, ` +
      `fail=${stats.failureCount}, duration=${stats.totalDuration}ms, tokens=${stats.totalTokens}`;
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/metrics/collector.test.ts
```

Expected: PASS (all 7 tests)

### Step 5: Create mod.ts

Create `src/goldflow/metrics/mod.ts`:

```typescript
// src/goldflow/metrics/mod.ts
export { MetricsCollector, type AggregateStats } from './collector.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/metrics/
git commit -m "feat(goldflow): add MetricsCollector with aggregate stats"
```

---

## Task 5.1.3: Create Base Controller

**bd issue:** Create via `bd create --title="Create BaseController" --type=task`

**Files:**
- Create: `src/goldflow/controllers/base.ts`
- Create: `src/goldflow/controllers/mod.ts`
- Test: `src/goldflow/controllers/base.test.ts`

### Step 1: Write the failing test

Create `src/goldflow/controllers/base.test.ts`:

```typescript
// src/goldflow/controllers/base.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { BaseController } from './base.ts';
import type { GoldflowComponent, GoldflowResult } from '../types.ts';

// Mock component for testing
const mockProcessor: GoldflowComponent = {
  type: 'processor',
  name: 'test-processor',
  config: {},
};

Deno.test('BaseController - can be instantiated with name', () => {
  const controller = new BaseController('test-controller');
  assertEquals(controller.name, 'test-controller');
  assertEquals(controller.type, 'controller');
});

Deno.test('BaseController - orchestrate() returns success by default', async () => {
  const controller = new BaseController('test-controller');
  const result = await controller.orchestrate([mockProcessor]);

  assertEquals(result.success, true);
});

Deno.test('BaseController - config can be set', () => {
  const controller = new BaseController('test-controller', {
    maxParallel: 3,
    retryPolicy: 2,
  });

  assertEquals(controller.config.maxParallel, 3);
  assertEquals(controller.config.retryPolicy, 2);
});

Deno.test('BaseController - superpowers can be specified', () => {
  const controller = new BaseController('test-controller', {
    superpowers: ['dispatching-parallel-agents'],
  });

  assertExists(controller.superpowers);
  assertEquals(controller.superpowers?.length, 1);
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/controllers/base.test.ts
```

Expected: FAIL with module not found

### Step 3: Create base.ts

Create `src/goldflow/controllers/base.ts`:

```typescript
// src/goldflow/controllers/base.ts
import type { Controller, GoldflowComponent, GoldflowResult } from '../types.ts';

export interface ControllerConfig {
  maxParallel?: number;
  retryPolicy?: number;
  superpowers?: string[];
  [key: string]: unknown;
}

/**
 * BaseController - Foundation for all Goldflow controllers.
 *
 * Controllers orchestrate components (sources, processors, verifiers, sinks)
 * to execute pipelines reliably. They handle retry logic, parallel execution,
 * and error recovery.
 */
export class BaseController implements Controller {
  readonly type = 'controller' as const;
  readonly name: string;
  readonly config: ControllerConfig;
  readonly superpowers?: string[];
  readonly maxParallel?: number;

  constructor(name: string, config: ControllerConfig = {}) {
    this.name = name;
    this.config = config;
    this.superpowers = config.superpowers;
    this.maxParallel = config.maxParallel;
  }

  /**
   * Orchestrate a set of components.
   * Override in subclasses for specific orchestration logic.
   */
  async orchestrate(components: GoldflowComponent[]): Promise<GoldflowResult<void>> {
    const startTime = Date.now();

    // Base implementation just succeeds
    // Subclasses implement actual orchestration logic

    return {
      success: true,
      data: undefined,
      metrics: {
        startTime,
        endTime: Date.now(),
      },
    };
  }

  /**
   * Execute with retry policy.
   */
  protected async withRetry<T>(
    fn: () => Promise<GoldflowResult<T>>,
    retries: number = this.config.retryPolicy || 0,
  ): Promise<GoldflowResult<T>> {
    let lastError: string = 'Unknown error';

    for (let attempt = 0; attempt <= retries; attempt++) {
      const result = await fn();
      if (result.success) {
        return result;
      }
      lastError = result.error;
    }

    return {
      success: false,
      error: `Failed after ${retries + 1} attempts: ${lastError}`,
      metrics: { startTime: Date.now(), endTime: Date.now() },
    };
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/controllers/base.test.ts
```

Expected: PASS (all 4 tests)

### Step 5: Create mod.ts

Create `src/goldflow/controllers/mod.ts`:

```typescript
// src/goldflow/controllers/mod.ts
export { BaseController, type ControllerConfig } from './base.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/controllers/
git commit -m "feat(goldflow): add BaseController with retry support"
```

---

## Task 5.1.4: Create Base Verifier

**bd issue:** Create via `bd create --title="Create BaseVerifier" --type=task`

**Files:**
- Create: `src/goldflow/verifiers/base.ts`
- Create: `src/goldflow/verifiers/mod.ts`
- Test: `src/goldflow/verifiers/base.test.ts`

### Step 1: Write the failing test

Create `src/goldflow/verifiers/base.test.ts`:

```typescript
// src/goldflow/verifiers/base.test.ts
import { assertEquals, assertExists } from 'https://deno.land/std@0.208.0/assert/mod.ts';
import { BaseVerifier } from './base.ts';
import type { GateResult } from '../types.ts';

Deno.test('BaseVerifier - can be instantiated with gates', () => {
  const verifier = new BaseVerifier('test-verifier', ['gate1', 'gate2']);

  assertEquals(verifier.name, 'test-verifier');
  assertEquals(verifier.type, 'verifier');
  assertEquals(verifier.gates.length, 2);
});

Deno.test('BaseVerifier - verify() runs all gates', async () => {
  const verifier = new BaseVerifier('test-verifier', ['tests_pass', 'lint_clean']);

  // Add gate handlers
  verifier.addGate('tests_pass', async () => ({
    gateName: 'tests_pass',
    passed: true,
    message: 'All tests passed',
  }));

  verifier.addGate('lint_clean', async () => ({
    gateName: 'lint_clean',
    passed: true,
    message: 'No lint errors',
  }));

  const result = await verifier.verify({});

  assertEquals(result.success, true);
  if (result.success) {
    assertEquals(result.data.length, 2);
    assertEquals(result.data.every((g) => g.passed), true);
  }
});

Deno.test('BaseVerifier - verify() fails if any gate fails', async () => {
  const verifier = new BaseVerifier('test-verifier', ['tests_pass', 'lint_clean']);

  verifier.addGate('tests_pass', async () => ({
    gateName: 'tests_pass',
    passed: false,
    message: '3 tests failed',
  }));

  verifier.addGate('lint_clean', async () => ({
    gateName: 'lint_clean',
    passed: true,
    message: 'No lint errors',
  }));

  const result = await verifier.verify({});

  assertEquals(result.success, true); // Verify itself succeeds
  if (result.success) {
    const allPassed = result.data.every((g) => g.passed);
    assertEquals(allPassed, false); // But not all gates passed
  }
});

Deno.test('BaseVerifier - allGatesPassed() helper works', async () => {
  const verifier = new BaseVerifier('test-verifier', ['gate1']);

  verifier.addGate('gate1', async () => ({
    gateName: 'gate1',
    passed: true,
    message: 'OK',
  }));

  const result = await verifier.verify({});

  if (result.success) {
    assertEquals(verifier.allGatesPassed(result.data), true);
  }
});
```

### Step 2: Run test to verify it fails

```bash
deno test --allow-all src/goldflow/verifiers/base.test.ts
```

Expected: FAIL with module not found

### Step 3: Create base.ts

Create `src/goldflow/verifiers/base.ts`:

```typescript
// src/goldflow/verifiers/base.ts
import type { Verifier, GoldflowResult, GateResult } from '../types.ts';

export type GateHandler = (input: unknown) => Promise<GateResult>;

export interface VerifierConfig {
  superpowers?: string[];
  [key: string]: unknown;
}

/**
 * BaseVerifier - Foundation for all Goldflow verifiers.
 *
 * Verifiers run quality gates on outputs. Each gate is a check
 * (tests pass, lint clean, security scan, etc.) that returns pass/fail.
 */
export class BaseVerifier implements Verifier {
  readonly type = 'verifier' as const;
  readonly name: string;
  readonly gates: string[];
  readonly config: VerifierConfig;
  readonly superpowers?: string[];

  private gateHandlers: Map<string, GateHandler> = new Map();

  constructor(name: string, gates: string[], config: VerifierConfig = {}) {
    this.name = name;
    this.gates = gates;
    this.config = config;
    this.superpowers = config.superpowers;
  }

  /**
   * Add a gate handler function.
   */
  addGate(gateName: string, handler: GateHandler): void {
    this.gateHandlers.set(gateName, handler);
  }

  /**
   * Run all gates and return results.
   */
  async verify(input: unknown): Promise<GoldflowResult<GateResult[]>> {
    const startTime = Date.now();
    const results: GateResult[] = [];

    for (const gateName of this.gates) {
      const handler = this.gateHandlers.get(gateName);

      if (handler) {
        try {
          const result = await handler(input);
          results.push(result);
        } catch (error) {
          results.push({
            gateName,
            passed: false,
            message: `Gate error: ${error instanceof Error ? error.message : String(error)}`,
          });
        }
      } else {
        // No handler registered - gate not implemented
        results.push({
          gateName,
          passed: false,
          message: `Gate not implemented: ${gateName}`,
        });
      }
    }

    return {
      success: true,
      data: results,
      metrics: {
        startTime,
        endTime: Date.now(),
      },
    };
  }

  /**
   * Helper to check if all gates passed.
   */
  allGatesPassed(results: GateResult[]): boolean {
    return results.every((r) => r.passed);
  }

  /**
   * Get failed gates from results.
   */
  getFailedGates(results: GateResult[]): GateResult[] {
    return results.filter((r) => !r.passed);
  }

  /**
   * Format results for bd comment.
   */
  toBdComment(results: GateResult[]): string {
    const passed = results.filter((r) => r.passed).length;
    const total = results.length;
    const status = this.allGatesPassed(results) ? 'pass' : 'fail';

    const details = results
      .map((r) => `${r.passed ? '✓' : '✗'} ${r.gateName}: ${r.message}`)
      .join('\n');

    return `VERIFY_GATE: ${this.name}\nstatus: ${status}\ngates: ${passed}/${total} passed\n${details}`;
  }
}
```

### Step 4: Run test to verify it passes

```bash
deno test --allow-all src/goldflow/verifiers/base.test.ts
```

Expected: PASS (all 4 tests)

### Step 5: Create mod.ts

Create `src/goldflow/verifiers/mod.ts`:

```typescript
// src/goldflow/verifiers/mod.ts
export { BaseVerifier, type GateHandler, type VerifierConfig } from './base.ts';
```

### Step 6: Commit

```bash
git add src/goldflow/verifiers/
git commit -m "feat(goldflow): add BaseVerifier with gate handlers"
```

---

## Task 5.1.5: Create Goldflow Module Export

**bd issue:** Create via `bd create --title="Create goldflow mod.ts export" --type=task`

**Files:**
- Create: `src/goldflow/mod.ts`

### Step 1: Create mod.ts

Create `src/goldflow/mod.ts`:

```typescript
// src/goldflow/mod.ts
/**
 * Goldflow - Execution Engine
 *
 * The execution layer that handles HOW work gets done reliably.
 * No narrative/role concepts - those belong to Paydirt layer.
 */

// Core types
export * from './types.ts';

// Controllers
export * from './controllers/mod.ts';

// Verifiers
export * from './verifiers/mod.ts';

// Metrics
export * from './metrics/mod.ts';

// Pipelines (existing)
export * from './pipelines/mod.ts';
```

### Step 2: Run type check

```bash
deno check src/goldflow/mod.ts
```

Expected: No errors

### Step 3: Commit

```bash
git add src/goldflow/mod.ts
git commit -m "feat(goldflow): create main module export"
```

---

## Summary

| Task | Description | Files |
|------|-------------|-------|
| 5.1.1 | Extend core types | `types.ts`, `types.test.ts` |
| 5.1.2 | MetricsCollector | `metrics/collector.ts`, `metrics/mod.ts` |
| 5.1.3 | BaseController | `controllers/base.ts`, `controllers/mod.ts` |
| 5.1.4 | BaseVerifier | `verifiers/base.ts`, `verifiers/mod.ts` |
| 5.1.5 | Module export | `mod.ts` |

---

## Final Directory Structure After Phase 5.1

```
src/goldflow/
├── mod.ts                    # Main export
├── types.ts                  # Extended with Result, MetricEntry, GateResult
├── types.test.ts             # Type tests
├── controllers/
│   ├── mod.ts
│   ├── base.ts               # BaseController
│   └── base.test.ts
├── verifiers/
│   ├── mod.ts
│   ├── base.ts               # BaseVerifier with gates
│   └── base.test.ts
├── metrics/
│   ├── mod.ts
│   ├── collector.ts          # MetricsCollector
│   └── collector.test.ts
└── pipelines/
    ├── mod.ts                # Existing
    └── delivery.ts           # Existing
```
